import re

from django.core.management import call_command
import pytest


@pytest.mark.django_db
def test_rest_list_analysis_types(authenticated_api_client, project):
    from uvdat.core.tasks.analytics import __all__ as analysis_types

    analysis_type_instances = [at() for at in analysis_types]
    resp = authenticated_api_client.get(f'/api/v1/analytics/project/{project.id}/types/')
    data = resp.json()
    assert len(data) == 4
    assert set(type_info.get('name') for type_info in data) == set(
        i.name for i in analysis_type_instances
    )
    for type_info in data:
        instance = next(iter(i for i in analysis_type_instances if i.name == type_info.get('name')))
        assert type_info.get('description') == instance.description
        assert type_info.get('attribution') == instance.attribution
        assert type_info.get('input_types') == instance.input_types
        assert type_info.get('output_types') == instance.output_types
        input_options = type_info.get('input_options')
        for k, v in instance.get_input_options().items():
            assert len(input_options.get(k)) == len(v)


@pytest.mark.parametrize(
    'task', ['flood_simulation', 'flood_network_failure', 'network_recovery', 'segment_curbs']
)
@pytest.mark.django_db
def test_rest_run_analysis_task_no_inputs(authenticated_api_client, user, project, task):
    project.set_followers([user])
    resp = authenticated_api_client.post(
        f'/api/v1/analytics/project/{project.id}/types/{task}/run/'
    )
    data = resp.json()

    # evaluate initial response
    assert data.get('analysis_type') == task
    assert data.get('project') == project.id
    assert data.get('status') == 'Initializing task...'
    assert data.get('inputs') == {}
    assert data.get('error') is None
    assert data.get('outputs') is None
    assert data.get('completed') is None

    # result object should encounter error due to lack of inputs
    result_id = data.get('id')
    resp = authenticated_api_client.get(f'/api/v1/analytics/{result_id}/')
    data = resp.json()
    assert data.get('id') == result_id
    assert data.get('analysis_type') == task
    assert data.get('error') is not None
    assert re.search(r'(.+) not provided', data.get('error')) is not None
    assert re.search(r'Completed in (\d|.)+ seconds.', data.get('status')) is not None


@pytest.mark.slow
@pytest.mark.django_db
def test_flood_analysis_chain(project):
    from django.contrib.auth.models import User

    from uvdat.core.models import Chart, Dataset, Network
    from uvdat.core.tasks.analytics import FloodNetworkFailure, FloodSimulation, NetworkRecovery

    # ensure a superuser exists
    User.objects.create_superuser('testsuper')

    # ingest necessary objects
    call_command(
        'ingest',
        'boston_floods.json',
        include_large=False,
        dataset_indexes=[0],  # dataset 0 is MBTA network
    )
    network = Network.objects.get(name='MBTA Rapid Transit Network 1')
    chart = Chart.objects.get(name='Parabolic Hyetograph')

    # run flood simulation task
    result_1 = FloodSimulation().run_task(
        project=project,
        precipitation=chart.id,
        likelihood='1 in 100 year (1% chance)',
        time_period='2080-2100',
    )
    result_1.refresh_from_db()
    assert result_1.completed is not None
    assert result_1.error is None
    assert result_1.outputs is not None

    flood_dataset_id = result_1.outputs.get('flood')
    assert flood_dataset_id is not None
    flood_dataset = Dataset.objects.get(id=flood_dataset_id)
    assert (
        flood_dataset.name == 'Parabolic 1 in 100 year (1% chance) Flood Simulation for 2080-2100'
    )
    assert flood_dataset.description == 'Generated by Flood Simulation Analysis Task'
    assert flood_dataset.category == 'flood'

    metadata = flood_dataset.metadata
    assert metadata.get('likelihood') == '1 in 100 year (1% chance)'
    assert metadata.get('downscaling', {}).get('time_period') == '2080-2100'
    assert metadata.get('precipitation', {}).get('hyetograph') == 'Parabolic'

    layer = flood_dataset.layers.first()
    assert layer.frames.count() == 100

    # run flood network failure task
    result_2 = FloodNetworkFailure().run_task(
        project=project,
        network=network.id,
        flood_simulation=result_1.id,
        depth_tolerance_meters=0.1,
        station_radius_meters=30,
    )
    result_2.refresh_from_db()
    assert result_2.completed is not None
    assert result_2.error is None
    assert result_2.outputs is not None

    failures = result_2.outputs.get('failures')
    assert len(failures) == 100
    assert len(failures['0']) == 54
    assert len(failures['50']) == 121
    assert len(failures['99']) == 134

    # run network recovery task
    result_3 = NetworkRecovery().run_task(
        project=project,
        network_failure=result_2.id,
        recovery_mode='degree',
    )
    result_3.refresh_from_db()
    assert result_3.completed is not None
    assert result_3.error is None
    assert result_3.outputs is not None

    recoveries = result_3.outputs.get('recoveries')
    assert len(recoveries) == 135
    assert len(recoveries['0']) == 134
    assert len(recoveries['133']) == 1
